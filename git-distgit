#!/bin/bash
set -e

SUBDIRECTORY_OK=Yes
OPTIONS_SPEC="\
git redist-git [options] <cmd> ...

regenerate patches for dist-git
--
h,help show the help
usage* show the help
r,remote!=remote the name of the remote in the source-git repo
n,dry-run do not actually make any changes
f,force force override previously staged changes
x set -x
"
OPTIONS_KEEPDASHDASH=
OPTIONS_STUCKLONG=t

. "$(git --exec-path)/git-sh-setup"

set -u
for x in "${@}" ; do
	if [[ "${x}" = -x ]] ; then
		set -x

	fi
done

declare -a trash=()

cleanup() {
	for x in "${trash[@]}" ; do
		if [[ -z "${x}" ]] ; then
			continue
		fi
		if [[ "${x}" -ef / ]] ; then
			continue
		fi
		if [[ "${x}" -ef "${HOME}" ]] ; then
			continue
		fi
		if [[ -d "${x}" ]] ; then
			rm -rf "${x}"
		else
			rm -f "${x}"
		fi
	done
}

trap 'cleanup ; exit $?' INT TERM EXIT

qpushd() {
	pushd "${@}" >/dev/null 2>&1
}

qpopd() {
	popd "${@}" >/dev/null 2>&1
}

bool() {
	local var="${1}" && shift
	local args=("${@}")
	if [[ -v args[0] ]] ; then
		local default="${args[0]}"
	else
		local default=""
	fi

	if [[ -z "${var}" ]] ; then
		var="${default}"
	fi
	case "${var}" in
	false|0|no|off)
		var=false
		;;
	true|1|yes|on)
		var=true
		;;
	*)
		var="${default}"
		;;
	esac
	echo "${var}"
}

testbool() {
	echo "--$1|--no-$1|--$1=*"
}

parsebool() {
	case "$2" in
	"--$1"|"--$1=true"|"--$1=1"|"--$1=yes"|"--$1=on")
		echo true
		return 0
		;;
	"--no-$1"|"--$1=false"|"--$1=0"|"--$1=no"|"--$1=off")
		echo false
		return 0
		;;
	esac
	return 1
}

getcfg() {
	local var="$(git config --get "${1}")"
	local args=("${@}")
	if [[ -n "${var}" ]] ; then
		echo "${var}"
	elif [[ -v args[1] ]] ; then
		echo "${args[1]}"
	fi
}

getbool() {
	local first=$1 && shift
	bool $(getcfg "${first}") "${@}"
}

hascfg() {
	[[ -n "$(getcfg "${1}")" ]]
}

get-branch() {
	local ref=$(getcfg distgit.branch)
	if [[ -n "${ref}" ]] ; then
		echo "${ref}"
		return 0
	fi

	qpushd "${distgit}"
	ref=$(git symbolic-ref HEAD)
	ref="${ref##*/}"
	qpopd

	if [[ -n "${ref}" ]] ; then
		echo "${ref}"
		return 0
	fi

	ref=$(git symbolic-ref HEAD)
	ref="${ref##*/}"
	echo "${ref}"
}

get-branchpoint() {
	local ref=$(getcfg distgit.branchpoint)
	if [[ -n "${ref}" ]] ; then
		echo "${ref}"
		return 0
	fi

	qpushd "${distgit}"
	ref=$(getcfg "branch.${branch}.merge" || :;)
	ref="${ref##*/}"
	qpopd

	echo "${ref}"
}

mk-order-file() {
	local orderfile="${1}" && shift
	cat >"${orderfile}" <<EOF
*.dec
*.dsc.inc
*.dsc
*.fdf
*.inf
*.vfr
*.ac
*.def
*.c
*.C
*.cpp
*.h
*.S
*.mk
Makefile.*
Make.*
Makefile
EOF
}

declare distgit="$(getcfg distgit.path)"
declare branch="$(getcfg distgit.branch)"
declare branchpoint="$(getcfg distgit.branchpoint)"
declare -a cmdopts=()
declare -l dry_run=$(getbool distgit.dry-run false)
declare -l fetch=$(getbool distgit.fetch true)
declare -l force=$(getbool distgit.force false)
declare patchfile="$(getcfg distgit.patchfile patches)"
declare remote="$(getcfg distgit.remote origin)"
declare cmd=""

while [ $# -ge 1 ]; do
	if [[ -n "${cmd}" ]] ; then
		cmdopts[${#cmdopts[*]}]="$1"
		shift
		continue
	fi
	case $1 in
	--distgit=*)
		distgit=${1#--distgit=}
		;;
	--distgit)
		shift
		distgit=${1}
		;;
	--branch=*)
		branch=${1#--branch=}
		;;
	--branch)
		shift
		branch=${1}
		;;
	--branchpoint=*)
		branchpoint=${1#--branchpoint=}
		;;
	--branchpoint)
		shift
		branchpoint=${1}
		;;
	--dry-run|--no-dry-run|--dry-run=*)
		dry_run="$(parsebool dry-run "$1")"
		;;
	--fetch|--no-fetch|--fetch=*)
		fetch="$(parsebool fetch "$1")"
		;;
	--force|--no-force|--force=*)
		force="$(parsebool force "$1")"
		;;
	--patchfile=*)
		patchfile=${1#--patchfile=}
		;;
	--patchfile)
		shift
		patchfile=${1}
		;;
	--remote=*)
		remote=${1#--remote=}
		;;
	--remote)
		shift
		remote=${1}
		;;
	-x)
		;;
	--)
		if [[ ${#cmdopts[*]} -eq 0 ]] ; then
			cmdopts[${#cmdopts[*]}]=$1
			shift
			cmd="$1"
		else
			cmdopts[${#cmdopts[*]}]=$1
		fi
		;;
	*)
		if [[ ${#cmdopts[*]} -eq 0 ]] ; then
			cmd="$1"
		else
			cmdopts[${#cmdopts[*]}]=$1
			shift
		fi
		;;
	esac
	shift
done

if [[ -z "${distgit}" ]] ; then
	distgit="$(getcfg distgit.path)"
fi
if [[ -z "${distgit}" ]] ; then
	echo "distgit: error: distgit.path not set.  Run the following:" 1>&2
	echo "git config --local --add distgit.path /PATH/TO/DIST-GIT/CHECKOUT" 1>&2
	exit 1
fi
if ! [[ -d "${distgit}" ]] ; then
	echo "distgit: error: \"${distgit}\" is not a directory." 1>&2
	exit 1
fi

if [[ -z "${branch}" ]] ; then
	branch="$(get-branch)"
fi
if [[ -z "${branch}" ]] ; then
	echo "dist-git: error: distgit.branch not set.  Run the following:" 1>&2
	echo "git config --local --add distgit.branch DIST-GIT-BRANCH-NAME" 1>&2
	exit 1
fi

if [[ -z "${branchpoint}" ]] ; then
	branchpoint="$(get-branchpoint "${branch}")"
fi
if [[ -z "${branchpoint}" ]] ; then
	echo "dist-git: error: distgit.branchpoint not set.  Run the following:" 1>&2
	echo "git config --local --add distgit.branchpoint DIST-GIT-branchpoint-NAME" 1>&2
	exit 1
fi

if ! [[ -v cmdopts[0] ]] ; then
	echo "No command specified." >>/dev/stderr
	usage >>/dev/stderr
fi

if [[ -z "${cmd}" ]] && [[ ${#cmdopts[@]} -gt 0 ]] ; then
	declare cmd="${cmdopts[0]}"
	unset cmdopts[0]
fi
if [[ -v cmdopts[0] ]] && [[ "${cmdopts[0]}" = "--" ]] ; then
	unset cmdopts[0]
fi
if [[ -v cmdopts[1] ]] && [[ "${cmdopts[1]}" = "--" ]] ; then
	unset cmdopts[1]
fi
cmdopts=("${cmdopts[@]}")

rebase-from-distgit() {(
	local args=()
	if [[ "${force}" = true ]] ; then
		args[${#args[*]}]=-f
	fi
	if [[ "${dry_run}" = true ]] ; then
		args[${#args[*]}]=-n
	fi

	local fmt_args=(--zero-commit --no-signature --no-numbered --stat=80 --summary --patience -l0)
	if ! hascfg diff.orderFile ; then
		local orderfile=$(mktemp)
		fmt_args[${#fmt_args[*]}]="-O${orderfile}"
		trash[${#trash[*]}]="${orderfile}"
		mk-order-file "${orderfile}"
	fi

	if [[ -f "${patchfile}" ]] ; then
		cat "${patchfile}" | while read dude filename whatever ; do
			# this means it's not a git format-patch patch
			if ! [[ ${filename} =~ [[:digit:]]+-.*\.patch ]] ; then
				continue
			fi
			if ! [[ -f "${filename}" ]] ; then
				continue
			fi
			git rm -q "${args[@]}" ${filename}
		done
	fi
	qpushd "${distgit}"
	local OLD_GIT_DIR="${GIT_DIR}"
	local OLD_GIT_OBJECT_DIRECTORY="${GIT_OBJECT_DIRECTORY}"
	unset GIT_DIR GIT_OBJECT_DIRECTORY
	: "${GIT_DIR="$(git rev-parse --git-dir)"}"
	: "${GIT_OBJECT_DIRECTORY="$(git rev-parse --git-path objects)"}"
	qpopd
	if [[ "${fetch}" = true ]] ; then
		GIT_DIR="${GIT_DIR}" GIT_OBJECT_DIRECTORY="${GIT_OBJECT_DIRECTORY}" \
			git fetch -q "${remote}"
	fi
	local patches=($(GIT_DIR="${GIT_DIR}" GIT_OBJECT_DIRECTORY="${GIT_OBJECT_DIRECTORY}" \
		git format-patch "${fmt_args[@]}" "${args[@]}" ${branchpoint}..${branch}))
	GIT_DIR="${OLD_GIT_DIR}"
	GIT_OBJECT_DIRECTORY="${OLD_GIT_OBJECT_DIRECTORY}"
	for patch in "${patches[@]}" ; do
		local x="${patch%%-*}"
		echo "Patch${x}: ${patch}"
	done > "${patchfile}"
	for patch in "${patches[@]}" ; do
		git add "${args[@]}" "${patch}"
	done
	git add "${args[@]}" "${patchfile}" >/dev/null
	if [[ "${dry_run}" = true ]] ; then
		git restore "${patchfile}" "${patches[@]}"
	fi
	git status
)}

case "${cmd}" in
	rebase)
		require_clean_work_tree rebase "Please commit or stash them."
		rebase-from-distgit "${cmdopts[@]}"
		;;
	*)
		echo "No such command ${cmd}" >>/dev/stderr
		usage >>/dev/stderr
		;;
esac
